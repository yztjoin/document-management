#### [330. 按要求补齐数组](https://leetcode-cn.com/problems/patching-array/)

难度困难221

给定一个已排序的正整数数组 *nums，*和一个正整数 *n 。*从 `[1, n]` 区间内选取任意个数字补充到 *nums* 中，使得 `[1, n]` 区间内的任何数字都可以用 *nums* 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。

变量：正整数 数组 nums、正整数 n 、

条件：从[1, n]选取任意数字补充到nums，`[1, n]` 区间内的任何数字  都可以用数组内某几个数字的和表示

示例 1:

输入: nums = [1,3], n = 6
输出: 1 
解释:
根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。
现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。
其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。
所以我们最少需要添加一个数字。
示例 2:

输入: nums = [1,5,10], n = 20
输出: 2
解释: 我们需要添加 [2, 4]。
示例 3:

输入: nums = [1,2,2], n = 5
输出: 0





当遇到多种实现方式的时候，想象用户在该环境最大概率会如何操作，心理学或把自己带入



称重思想

```yaml
如果我有砝码0，能称的重量为0
再加一个砝码1，能称的重量不到2    1
再加一个砝码2，能称的重量不到4    1    1+2
再加一个砝码4，能称的重量不到8    1    2    1+2    4  1+4    1+2+4
再加一个砝码8，能称的重量不到16（16以内的全都能称出来）
因为我每次前一步已经完全覆盖[0，n),再加一个n kg的不就能覆盖[0，2n)了吗。
同时为了加的次数最少我们才这样加，不需要1，2，3，4，5.....每种砝码都有。
只有这样先做到局部加砝码最少，才能保证到后边n很大时加的砝码最少。
```

对于正整数 xx，如果区间[ [1,x-1][1,x−1] ]内的所有数字都已经被覆盖，且 xx 在数组中，则区间 [[1,2x-1][1,2x−1] ]内的所有数字也都被覆盖。

#### [1046. 最后一块石头的重量](https://leetcode-cn.com/problems/last-stone-weight/)

难度简单113

有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出两块 **最重的** 石头，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 `0`。

 

**示例：**

```
输入：[2,7,4,1,8,1]
输出：1
解释：
先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，
再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，
接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，
最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。
```

 

**提示：**

1. `1 <= stones.length <= 30`
2. `1 <= stones[i] <= 1000`

取两个最重的石头进行粉碎 返回两者的差值加入数组  为0 则过